nngp_precision <- function(s, m, phi){
pty <- Sys.time()
n = nrow(s)
m = min(m, n-1)
#imvec <- sapply(2:n, myknn, s, m)
#Dimvec <- sapply(2:n, Dimgen, imvec, s)
colind = c(1:n, unlist(imvec))
mi=c(1:(m - 1), rep(m, n - m))
rowind = c(1:n,unlist(sapply(2:n, function(i,mi) rep(i,mi[i-1]), mi)))
wimvec=sapply(2:n, function(i,Dimvec,par) {D = exp(-par*as.matrix(Dimvec[[i-1]]));as.vector(solve(D[-1,-1])%*%D[1,-1])},Dimvec,phi)
fimvec=sapply(2:n, function(i,Dimvec,wimvec,par) {D=as.matrix(Dimvec[[i-1]]);1-exp(-par*D[1,-1])%*%wimvec[[i-1]]}, Dimvec,wimvec,phi)
V=sparseMatrix(i = rowind, j = colind, x = c(rep(1, n), -unlist(wimvec)),dims=c(n,n))
F=sparseMatrix(i = 1:n, j = 1:n, x = c(1, 1 / fimvec), dims = c(n,n))
nngpprec=t(V)%*%F%*%V
t <-  Sys.time() - pty; cat(t)
}
set.seed(1)
n=5
s=cbind(sort(runif(n,0,1)),runif(n,0,1))
phi=1
m=6
pty <- Sys.time(); exp_GP_prec=solve(exp(-phi*as.matrix(dist(s)))) ;t <-  Sys.time() - pty; t
pty <- Sys.time(); exp_GP_prec=chol2inv(chol(exp(-phi*as.matrix(dist(s))))) ;t <-  Sys.time() - pty; t
pty <- Sys.time(); exp_NNGP_prec=nngp_precision(s,m,phi)
imvec <- sapply(2:n, myknn, s, m)
Dimgen = function(i,imvec,s)	dist(s[c(i,imvec[[i-1]]),])
nngp_precision <- function(s, m, phi){
pty <- Sys.time()
n = nrow(s)
m = min(m, n-1)
imvec <- sapply(2:n, myknn, s, m)
Dimvec <- sapply(2:n, Dimgen, imvec, s)
colind = c(1:n, unlist(imvec))
mi=c(1:(m - 1), rep(m, n - m))
rowind = c(1:n,unlist(sapply(2:n, function(i,mi) rep(i,mi[i-1]), mi)))
wimvec=sapply(2:n, function(i,Dimvec,par) {D = exp(-par*as.matrix(Dimvec[[i-1]]));as.vector(solve(D[-1,-1])%*%D[1,-1])},Dimvec,phi)
fimvec=sapply(2:n, function(i,Dimvec,wimvec,par) {D=as.matrix(Dimvec[[i-1]]);1-exp(-par*D[1,-1])%*%wimvec[[i-1]]}, Dimvec,wimvec,phi)
V=sparseMatrix(i = rowind, j = colind, x = c(rep(1, n), -unlist(wimvec)),dims=c(n,n))
F=sparseMatrix(i = 1:n, j = 1:n, x = c(1, 1 / fimvec), dims = c(n,n))
nngpprec=t(V)%*%F%*%V
t <-  Sys.time() - pty; cat(t)
}
set.seed(1)
n=5
s=cbind(sort(runif(n,0,1)),runif(n,0,1))
phi=1
m=6
pty <- Sys.time(); exp_GP_prec=solve(exp(-phi*as.matrix(dist(s)))) ;t <-  Sys.time() - pty; t
pty <- Sys.time(); exp_GP_prec=chol2inv(chol(exp(-phi*as.matrix(dist(s))))) ;t <-  Sys.time() - pty; t
pty <- Sys.time(); exp_NNGP_prec=nngp_precision(s,m,phi)
library('Matrix')
library("fields")
library(rstan)
model_code <-
"
functions {
matrix getADstan(matrix neardist, matrix neardistM,
matrix nearind, int N, int M, real phi) {
int dim;
int h;
matrix[N, M + 1] AD;
for (i in 2:N) {
matrix[ i < (M + 1)? (i - 1) : M, i < (M + 1)? (i - 1): M] temp_neardistM;
matrix[ i < (M + 1)? (i - 1) : M, i < (M + 1)? (i - 1): M] L;
vector[ i < (M + 1)? (i - 1) : M] u;
vector[ i < (M + 1)? (i - 1) : M] v;
row_vector[i < (M + 1)? (i - 1) : M] v2;
dim = (i < (M + 1))? (i-1) : M;
//print(i);
// get exp(-phi * neardistM)
if(dim == 1){temp_neardistM[1, 1] = 1;}
else{
h = 0;
for (j in 1:(dim - 1)){
for (k in (j + 1):dim){
h = h + 1;
temp_neardistM[j, k] = exp(- phi * neardistM[(i - 1), h]);
temp_neardistM[k, j] = temp_neardistM[j, k];
}
}
for(j in 1:dim){
temp_neardistM[j, j] = 1;
}
}
L = cholesky_decompose(temp_neardistM);
for (j in 1: dim){
u[j] = exp(- phi * neardist[(i - 1), j]);
}
//vector[dim] v;
v = mdivide_left_tri_low(L, u);
AD[i, (M+1)] = (1.0 - (v' * v));
v2 = mdivide_right_tri_low(v', L);
for(j in 1:dim){
AD[i, j] = v2[j];
}
}
AD[1, (M+1)] = 1;
return AD;}
}
model {}
"
expose_stan_functions(stanc(model_code = model_code))
library(rstan)
stan_version()
citation()
citation("rstan")
citation()
citation("RcppEigen")
citation("gstat")
print(gstat,
bibtex=TRUE)
print(<Pebesma, E.J., 2004. Multivariable geostatistics in S: the gstat
package. Computers & Geosciences, 30: 683-691.
Benedikt Gräler, Edzer Pebesma and Gerard Heuvelink, 2016.
Spatio-Temporal Interpolation using gstat.  The R Journal 8(1),
204-218>,
bibtex=TRUE)
print(<Pebesma, E.J., 2004. Multivariable geostatistics in S: the gstat
package. Computers & Geosciences, 30: 683-691.
Benedikt Gräler, Edzer Pebesma and Gerard Heuvelink, 2016.
Spatio-Temporal Interpolation using gstat.  The R Journal 8(1),
204-218>,
bibtex=TRUE)
1/0.9257499
sqrt(1.51003603)
sqrt(0.04426536)
2* 0.210
2* 1.22883
library()
library()
library(geoR)
library(geoR)
rm(list=ls())
library(spNNGP)
library(MBA)
library(fields)
rmvn <- function(n, mu=0, V = matrix(1)){
p <- length(mu)
if(any(is.na(match(dim(V),p))))
stop("Dimension problem!")
D <- chol(V)
t(matrix(rnorm(n*p), ncol=p)%*%D + rep(mu,rep(n,p)))
}
data(CHM)
CHM <- CHM[CHM[,3]>0,]
sigma.sq.IG <- c(2, 15)
cov.model <- "exponential"
set.seed(1)
mod <- sample(1:nrow(CHM), 500000)
CHM.mod <- CHM[mod,]
theta.alpha <- c(0.07, 0.13)
names(theta.alpha) <- c("phi", "alpha")
m.c.big <- spConjNNGP(CHM.mod[,3] ~ 1, coords=CHM.mod[,1:2], n.neighbors = 10,
theta.alpha = theta.alpha,
n.omp.threads = 2,
sigma.sq.IG = sigma.sq.IG, cov.model = cov.model)
rm(list=ls())
library(spNNGP)
data(CHM)
CHM <- CHM[CHM[,3]>0,]
set.seed(1)
mod <- sample(1:nrow(CHM), 500000)
CHM.mod <- CHM[mod,]
sigma.sq.IG <- c(2, 15)
cov.model <- "exponential"
theta.alpha <- c(0.07, 0.13)
names(theta.alpha) <- c("phi", "alpha")
t <- proc.time()
m.c.big <- spConjNNGP(CHM.mod[,3] ~ 1, coords=CHM.mod[,1:2], n.neighbors = 10,
theta.alpha = theta.alpha,
n.omp.threads = 2,
sigma.sq.IG = sigma.sq.IG, cov.model = cov.model)
proc.time() - t
100 - 2*(100 - 98.61)
rm(list=ls())
2*(100 - 98.61)
2*(100 - 99.38)
11/4
sample <- c(7,6,6,3,2,5)
mean(sample)
var(sample)
m <- mean(sample)
sum((sample - m)^2)/5
11+2+8+5-100
19+20+10
1.1 109
1.1*109
21^2 - 4*108
0.1^(0.01)
2+6+9+4
2+4
8+1+7+2+1+4+9+9+4+1
100-8-8-3-4-9-9-5
100-8-2-5-2-9-6-2
2+7+2
2+7+13+8
2+2+4+3
8+6
1+12+4
8+4+8+9
1+5
7+1+9+4
13+8
1+7+4+1
(199*(4.798^2) + 99*4.296^2)/(300-2)
67.245 - 62.820
1.96*sqrt(21.50418)*sqrt(1/200 + 1/100)
4.425 + 1.113174
4.425 - 1.113174
(199*2.87^2 + 99*2.11^2)/298
5.51 - 3.58
1.96*sqrt(6.979534)*sqrt(1/200 + 1/100)
1.93 + 0.6341835
1.93 - 0.6341835
0.584*2.79/5.079
4*52 -12*2
4*52 -12^2
52/64
52/4
64/4
-20+25
25+18
36+7
25-18
36-7
19 - 30
library(rstan)
?print.stanfit
setwd("/Users/luzhang/Documents/Biostats/research/bitbucket/simulation_paper/resp_vs_rand")
rm(list = ls())
library(fields)
library(spBayes)
rmvn <- function(N, mu = 0, V = matrix(1)){
P <- length(mu)
if(any(is.na(match(dim(V), P))))
stop("Dimension problem!")
D <- chol(V)
t(matrix(rnorm(N * P), ncol = P) %*% D + rep(mu, rep(N, P)))
}
set.seed(123)
N <- 20
coords <- cbind(runif(N), runif(N))
sigma.sq <- 1
tau.sq <- 8
phi <- 12   # 30
deltasq <- tau.sq / sigma.sq
Y <- rep(0, N)
source("NNMatrix.R")
source("functions.R")
M = 8
library(spNNGP)
sigma.sq.IG <- c(2, sigma.sq)
cov.model <- "exponential"
theta.alpha <- c(phi, tau.sq/sigma.sq)
names(theta.alpha) <- c("phi", "alpha")
m.c <- spConjNNGP(Y ~ 1,
coords= coords,
n.neighbors = M,
theta.alpha = theta.alpha, k.fold = 1,
n.omp.threads = 2, return.neighbors = T,
sigma.sq.IG = sigma.sq.IG, cov.model = cov.model)
NN.matrix <- NNMatrix(N, m.c$coords.ord, m.c$n.indx[-1])
D <- as.matrix(dist(m.c$coords.ord))
R <- exp(-phi*D)
ind_x <-c(c(rep(2:M, times = 1:(M - 1)), rep(((M + 1) : N), each = M)), 1:N)
ind_y <- c(c(t(NN.matrix$nearind))[which(c(t(NN.matrix$nearind)) > 0)], 1:N)
AD <- getADstan(neardist = NN.matrix$neardist,  neardistM = NN.matrix$neardistM,
nearind = NN.matrix$nearind, N = N, M = M, phi = phi)
D <- AD[, M + 1]
I_A <- sparseMatrix(i = ind_x, j = ind_y, x = c(- c(t(AD[, 1:M]))[
which(!is.na(t(AD[, 1:M])))], rep(1, N)) )
AD_resp <- getADstan_resp(neardist = NN.matrix$neardist,
neardistM = NN.matrix$neardistM,
nearind = NN.matrix$nearind,
N = N, M = M, phi = phi, deltasq = tau.sq/sigma.sq)
D_resp <- AD_resp[, M + 1]
I_A_resp <- sparseMatrix(i = ind_x, j = ind_y,
x = c(- c(t(AD_resp[, 1:M]))[
which(!is.na(t(AD_resp[, 1:M])))], rep(1, N)) )
inv_Sigma_resp <- t(I_A_resp)%*%(I_A_resp/D_resp)
inv_I_A <- solve(I_A)
Sigma_rand <- inv_I_A%*%(t(inv_I_A)*D) + (tau.sq/sigma.sq)*diag(N)
Sigma_rand
inv_Sigma_resp
inv_Sigma_rand <- solve(Sigma_rand)
inv_Sigma_rand
summary(inv_Sigma_rand - inv_Sigma_resp)
ele_diff<-c(inv_Sigma_rand - inv_Sigma_resp)
summary(ele_diff)
ele_diff
sum(ele_diff)
str(inv_Sigma_rand)
str(ele_diff)
elediff <-ele_diff@x
elediff <-ele_diff$x
str(elediff)
elediff
as.vector(ele_diff)
summary(ele_diff[[1]])
c(ele_diff[[1]])
str(ele_diff[[1]])
summary(ele_diff[[1]]@x)
summary(inv_Sigma_rand@x)
summary(inv_Sigma_resp@x)
sum(ele_diff[[1]]@x)
sum(inv_Sigma_resp@x)
rm(list = ls())
library(fields)
library(spBayes)
rmvn <- function(N, mu = 0, V = matrix(1)){
P <- length(mu)
if(any(is.na(match(dim(V), P))))
stop("Dimension problem!")
D <- chol(V)
t(matrix(rnorm(N * P), ncol = P) %*% D + rep(mu, rep(N, P)))
}
set.seed(123)
N <- 30
coords <- cbind(runif(N), runif(N))
sigma.sq <- 1
tau.sq <- 8
phi <- 12   # 30
deltasq <- tau.sq / sigma.sq
Y <- rep(0, N)
source("NNMatrix.R")
source("functions.R")
M = 5
library(spNNGP)
sigma.sq.IG <- c(2, sigma.sq)
cov.model <- "exponential"
theta.alpha <- c(phi, tau.sq/sigma.sq)
names(theta.alpha) <- c("phi", "alpha")
m.c <- spConjNNGP(Y ~ 1,
coords= coords,
n.neighbors = M,
theta.alpha = theta.alpha, k.fold = 1,
n.omp.threads = 2, return.neighbors = T,
sigma.sq.IG = sigma.sq.IG, cov.model = cov.model)
NN.matrix <- NNMatrix(N, m.c$coords.ord, m.c$n.indx[-1])
setwd("/Users/luzhang/Documents/Biostats/research/bitbucket/simulation_paper/resp_vs_rand")
rm(list = ls())
library(fields)
library(spBayes)
rmvn <- function(N, mu = 0, V = matrix(1)){
P <- length(mu)
if(any(is.na(match(dim(V), P))))
stop("Dimension problem!")
D <- chol(V)
t(matrix(rnorm(N * P), ncol = P) %*% D + rep(mu, rep(N, P)))
}
set.seed(123)
N <- 30
coords <- cbind(runif(N), runif(N))
sigma.sq <- 1
tau.sq <- 8
phi <- 12   # 30
deltasq <- tau.sq / sigma.sq
Y <- rep(0, N)
source("NNMatrix.R")
source("functions.R")
M = 5
library(spNNGP)
sigma.sq.IG <- c(2, sigma.sq)
cov.model <- "exponential"
theta.alpha <- c(phi, tau.sq/sigma.sq)
names(theta.alpha) <- c("phi", "alpha")
m.c <- spConjNNGP(Y ~ 1,
coords= coords,
n.neighbors = M,
theta.alpha = theta.alpha, k.fold = 1,
n.omp.threads = 2, return.neighbors = T,
sigma.sq.IG = sigma.sq.IG, cov.model = cov.model)
NN.matrix <- NNMatrix(N, m.c$coords.ord, m.c$n.indx[-1])
D <- as.matrix(dist(m.c$coords.ord))
R <- exp(-phi*D)
ind_x <-c(c(rep(2:M, times = 1:(M - 1)), rep(((M + 1) : N), each = M)), 1:N)
ind_y <- c(c(t(NN.matrix$nearind))[which(c(t(NN.matrix$nearind)) > 0)], 1:N)
AD <- getADstan(neardist = NN.matrix$neardist,  neardistM = NN.matrix$neardistM,
nearind = NN.matrix$nearind, N = N, M = M, phi = phi)
D <- AD[, M + 1]
I_A <- sparseMatrix(i = ind_x, j = ind_y, x = c(- c(t(AD[, 1:M]))[
which(!is.na(t(AD[, 1:M])))], rep(1, N)) )
AD_resp <- getADstan_resp(neardist = NN.matrix$neardist,
neardistM = NN.matrix$neardistM,
nearind = NN.matrix$nearind,
N = N, M = M, phi = phi, deltasq = tau.sq/sigma.sq)
D_resp <- AD_resp[, M + 1]
I_A_resp <- sparseMatrix(i = ind_x, j = ind_y,
x = c(- c(t(AD_resp[, 1:M]))[
which(!is.na(t(AD_resp[, 1:M])))], rep(1, N)) )
inv_Sigma_resp <- t(I_A_resp)%*%(I_A_resp/D_resp)
inv_I_A <- solve(I_A)
Sigma_rand <- inv_I_A%*%(t(inv_I_A)*D) + (tau.sq/sigma.sq)*diag(N)
inv_Sigma_rand <- solve(Sigma_rand)
sum(inv_Sigma_rand@x)
sum(inv_Sigma_resp@x)
sum(abs(inv_Sigma_rand@x-inv_Sigma_resp@x))
sum(abs(inv_Sigma_resp@x))
sum(abs(inv_Sigma_rand-inv_Sigma_resp)@x)
sum((inv_Sigma_rand-inv_Sigma_resp)@x)
N <- 50
coords <- cbind(runif(N), runif(N))
sigma.sq <- 1
tau.sq <- 8
phi <- 12   # 30
deltasq <- tau.sq / sigma.sq
Y <- rep(0, N)
source("NNMatrix.R")
M = 5
m.c <- spConjNNGP(Y ~ 1,
coords= coords,
n.neighbors = M,
theta.alpha = theta.alpha, k.fold = 1,
n.omp.threads = 2, return.neighbors = T,
sigma.sq.IG = sigma.sq.IG, cov.model = cov.model)
NN.matrix <- NNMatrix(N, m.c$coords.ord, m.c$n.indx[-1])
D <- as.matrix(dist(m.c$coords.ord))
R <- exp(-phi*D)
ind_x <-c(c(rep(2:M, times = 1:(M - 1)), rep(((M + 1) : N), each = M)), 1:N)
ind_y <- c(c(t(NN.matrix$nearind))[which(c(t(NN.matrix$nearind)) > 0)], 1:N)
AD <- getADstan(neardist = NN.matrix$neardist,  neardistM = NN.matrix$neardistM,
nearind = NN.matrix$nearind, N = N, M = M, phi = phi)
D <- AD[, M + 1]
I_A <- sparseMatrix(i = ind_x, j = ind_y, x = c(- c(t(AD[, 1:M]))[
which(!is.na(t(AD[, 1:M])))], rep(1, N)) )
AD_resp <- getADstan_resp(neardist = NN.matrix$neardist,
neardistM = NN.matrix$neardistM,
nearind = NN.matrix$nearind,
N = N, M = M, phi = phi, deltasq = tau.sq/sigma.sq)
D_resp <- AD_resp[, M + 1]
I_A_resp <- sparseMatrix(i = ind_x, j = ind_y,
x = c(- c(t(AD_resp[, 1:M]))[
which(!is.na(t(AD_resp[, 1:M])))], rep(1, N)) )
inv_Sigma_resp <- t(I_A_resp)%*%(I_A_resp/D_resp)
inv_I_A <- solve(I_A)
Sigma_rand <- inv_I_A%*%(t(inv_I_A)*D) + (tau.sq/sigma.sq)*diag(N)
inv_Sigma_rand <- solve(Sigma_rand)
sum(abs(inv_Sigma_resp - inv_Sigma_rand)@x)
sum(abs(inv_Sigma_rand)@x)
set.seed(123)
N <- 100
coords <- cbind(runif(N), runif(N))
sigma.sq <- 1
tau.sq <- 8
phi <- 12   # 30
deltasq <- tau.sq / sigma.sq
Y <- rep(0, N)
M = 5
m.c <- spConjNNGP(Y ~ 1,
coords= coords,
n.neighbors = M,
theta.alpha = theta.alpha, k.fold = 1,
n.omp.threads = 2, return.neighbors = T,
sigma.sq.IG = sigma.sq.IG, cov.model = cov.model)
NN.matrix <- NNMatrix(N, m.c$coords.ord, m.c$n.indx[-1])
D <- as.matrix(dist(m.c$coords.ord))
R <- exp(-phi*D)
ind_x <-c(c(rep(2:M, times = 1:(M - 1)), rep(((M + 1) : N), each = M)), 1:N)
ind_y <- c(c(t(NN.matrix$nearind))[which(c(t(NN.matrix$nearind)) > 0)], 1:N)
AD <- getADstan(neardist = NN.matrix$neardist,  neardistM = NN.matrix$neardistM,
nearind = NN.matrix$nearind, N = N, M = M, phi = phi)
D <- AD[, M + 1]
I_A <- sparseMatrix(i = ind_x, j = ind_y, x = c(- c(t(AD[, 1:M]))[
which(!is.na(t(AD[, 1:M])))], rep(1, N)) )
AD_resp <- getADstan_resp(neardist = NN.matrix$neardist,
neardistM = NN.matrix$neardistM,
nearind = NN.matrix$nearind,
N = N, M = M, phi = phi, deltasq = tau.sq/sigma.sq)
D_resp <- AD_resp[, M + 1]
I_A_resp <- sparseMatrix(i = ind_x, j = ind_y,
x = c(- c(t(AD_resp[, 1:M]))[
which(!is.na(t(AD_resp[, 1:M])))], rep(1, N)) )
inv_Sigma_resp <- t(I_A_resp)%*%(I_A_resp/D_resp)
inv_I_A <- solve(I_A)
Sigma_rand <- inv_I_A%*%(t(inv_I_A)*D) + (tau.sq/sigma.sq)*diag(N)
inv_Sigma_rand <- solve(Sigma_rand)
sum(abs(inv_Sigma_resp - inv_Sigma_rand)@x)
sum(abs(inv_Sigma_resp)@x)
chol_Sigma <- chol(R+deltasq*diag(N))
chol_inv_Sigma_resp <- chol(inv_Sigma_resp)
Sigma_resp <- chol2inv(chol_inv_Sigma_resp)
inv_Sigma <- chol2inv(chol_Sigma)
sum(abs(inv_Sigma)@x)
sum(abs(inv_Sigma))
sum(abs(inv_Sigma - inv_Sigma_resp))
sum(abs(inv_Sigma - inv_Sigma_rand))
library(utils)
citation(spNNGP)
citation()
citation("spNNGP")
setwd("/Users/luzhang/Documents/Biostats/research/bitbucket/simulation_paper")
setwd("./stan_paper/data/sorted_x_order")
rm(list = ls())
load("../simdata/simdata.RData")
library(spNNGP)
library(MBA)
library(fields)
sigma.sq.IG <- c(as, bs)
cov.model <- "exponential"
theta.alpha <- as.matrix(expand.grid(3/seq(0.05,1,by=0.05), seq(0.1, 2,by=0.1)))
dim(theta.alpha)
theta.alpha
3/seq(0.05,1,by=0.05)
seq(0.1, 2,by=0.1)
dim(theta.alpha)
colnames(theta.alpha) <- c("phi", "alpha")
set.seed(1234)
m.c1 <- spConjNNGP(Y~X[, 2], coords=coords, n.neighbors = 10,
k.fold = 5, score.rule = "crps",
n.omp.threads = 2,
theta.alpha = theta.alpha, sigma.sq.IG = sigma.sq.IG,
cov.model = cov.model)
